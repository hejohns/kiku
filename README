------------------------------------------------------------
kiku
------------------------------------------------------------
Defined behavioral requirements for generic C programming
------------------------------------------------------------

Many ideas are taken from C++ and the naming convention
certainly reflects that. 
C++ is fast, but the debugging experience can be painful.

The goal of kiku is to standardize type requirements
to allow for generic programming while being easy to debug
and seamless for users to extend with their own types.

The goal is NOT raw performance. Go to C++ for that.
This is promote code reuse without suffering from excessive
code bloat and difficult to read type identifiers.

Notice of course that the casts to (void *) ditch all
notions of static typing. While this consequence is
not desirable, hopefully a malformed program will
crash extremely quickly.
All function pointers are const to reduce accidental
corruption.


**Naming rules**

Type requirements always begin with an uppercase letter
such as
OneTwoThree
while realized types always begin with a lowercase letter
such as
oneTwoThree

Standard type functions follow the format
TypeRequirement_functionName()

Type requirements are are not realized types.
To avoid using the same namespace,
DO NOT TYPEDEF TYPE REQUIREMENTS.

Realized types must provide a _init() inline function
that returns the same type, and a _free() inline function
that properly deallocated resources captured in _init().
i.e. all type instances must be able to be declared as
type type_inst = type_init(...);
and deallocated as
type_free(&type_inst);
